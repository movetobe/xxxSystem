## 操作指令

### 数据传送指令MOV
#### MOV S, D
* movb/movw/movl/movq分别传送1/2/4/8字节数据
* movabsq传送绝对的8字节
* 源操作数是一个立即数，存储在寄存器或者内存中
* 目的操作数要么是寄存器或者内存地址
* x86-64要求不能两个操作数都是内存地址，内存-####内存需要两条指令完成
* movl指令以寄存器作为目的时，会把该寄存器的高4字节置0

#### MOVZ S, R
* 把目的中剩余字节填充0
* movzbw/movzbl/movzbq/movzwl/movzwq

#### MOVS S, R
* 把目的剩余字节填充符号位
* movsbw/movsbl/movsbq/movswl/movswq/movslq
* cltq 将%eax符号拓展到%rax

### 压栈和弹栈指令
#### pushq S
* 将8字节压栈，栈指针保存在$\%rsp$中
* $R[\%rsp] = R[\%rsp] - 8$
* $M[R[\%rsp]] = S$

#### popq D
* 将8字节出栈
* $D = M[R[\%rsp]]$
* $R[\%rsp] = R[\%rsp] + 8$

### 算术与逻辑指令
#### leaq S, D
* 将S的地址加载到D中，即$D = \&S$

#### INC D
* $D = D + 1$

#### DEC D
* $D = D - 1$

#### NEG D
* $D = -D$

#### NOT D
* $D = ~D$

#### ADD S, D
* $D = D + S$

#### SUB S, D
* $D = D - S$

#### IMUL S, D
* $D = D * S$

#### XOR S, D
* $D = D ^ S$

#### OR S, D
* $D = D | S$

#### AND S, D
* $D = D \& S$

#### SAL k, D
* $D = D << k$

#### SHL k, D
* $D = D << k$

#### SAR k, D
* $D = D >> k$
* 算术右移

#### SHR k, D
* $D = D >> k$
* 逻辑右移

### 控制指令
#### CMP S1, S2
* 比较S1和S2的值
* 条件码寄存器：CF(进位标志)/ZF(零标志)/SF(符号标志)/OF(溢出标志)

#### jmp Label
* 直接跳转

#### jmp *Operand
* 间接跳转

#### je/jz/jne/jnz Label
* 相等/零 或者 不相等/非零的时候跳转
* 条件控制转移涉及分支预测，一旦预测失败，影响流水线，进而影响性能。
* 可以采用条件传送指令

#### 条件控制转移：
```
if (test-express) {
    then-express;
} else {
    else-express;
}
```
#### 条件传送：
```
v = then-express;
ve = else-express;
if (!test-express) v = ve;
```

### switch语句
* switch语句通过跳转表直接跳转到对应的分支上