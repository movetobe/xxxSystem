## 第十二章 并发编程
### 并发编程
* 基于进程的并发编程：多进程处理同一件事产生的并发
* 基于I/O多路复用的并发编程：select/poll/epoll
* 基于线程的并发编程：posix thread -> pthread

### 同步
* 信号量(semaphore)同步：P(s)/V(s)操作
    * P(s): 如果s非零，则将s减1，并立即返回。如果s为0，挂起线程，直到s变为0，会有一个V操作重启这个线程，重启后，P操作将s减1，并将控制权返回调用者
    * V(s): 将s加1，如果有线程阻塞在P操作等待s变为非0，那么V操作重启这些线程中的一个，然后该线程将s减1，完成P操作
* 二元信号量(binary semaphore)：互斥锁(mutex)
* 同步经典问题：
    * 生产者-消费者问题：如何同步两者共享的缓冲区
    * 读者-写者问题：如何同步读写缓冲区
        * 读者优先：不让读者等待，除非当前在读
        * 写者优先：在一个写者后到达的读者必须等待写者完成，即使该写者也在等待。

### 并发注意的问题
* 线程安全(thread safety)
* 可重入性(reentrant)
* 线程中使用库函数
* 竞争(race)
* 死锁(deadlock)