{"./":{"url":"./","title":"XSystem","keywords":"","body":"XSystem 自2017年毕业后至今已工作两年有余，是该把自己的成长点滴做些记录人生路很长，是一本厚书，此书很大，取名XSystem，致敬逝去的青春和时间 个人能力有限，如有纰漏，望各位看官批评指正。 2019.12.10于上海 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-13 19:22:23 "},"computer_system/":{"url":"computer_system/","title":"计算机系统","keywords":"","body":"Hello World Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-13 00:27:25 "},"computer_system/data_structure_and_algorithms/":{"url":"computer_system/data_structure_and_algorithms/","title":"数据结构与算法","keywords":"","body":"Hello, data structure and algorithms Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-13 00:27:25 "},"computer_system/data_structure_and_algorithms/double_pointers/contents.html":{"url":"computer_system/data_structure_and_algorithms/double_pointers/contents.html","title":"双指针","keywords":"","body":"双指针 双指针是指使用两个指针对线性数据结构进行遍历/搜索的方法。 双指针方法包括： 首尾指针 快慢指针 前后指针 双指针方法解析 首尾指针 首指针从线性表从前往后遍历，尾指针从线性表尾部往前遍历。 [剑指offer-57] 和为s的数字 输入一个递增排序的数组和一个数字s，在数组总查找两个数，使得他们的和正好是s。 如果有多对数字的和等于s，则输出任意一对即可。 如：输入数组[1, 2, 4, 7, 11, 15]和数字15，由于4 + 11 = 15，则输出[4, 11]即可 采用首尾指针的双指针方法，如图所示： 若nums[front] + nums[tail] 若nums[front] + nums[tail] > s，则说明nums[tail]太大了，需要减小，故tail--; 若nums[front] + nums[tail] == s，得到解； 结束条件front >= tail，无解 /* front-tail pointers to solve the problem. */ int target_sum(int *nums, int nums_size, int target, int *ret_array) { int front = 0; int tail = nums_size - 1; if ((!nums) || (!ret_array) || (nums_size target) { /* decrease left part */ tail--; } } return (front 对于上述方法，由于最多遍历整个数组的所有元素，故时间复杂度是O(n)。如果数组是没有排序的，且可以改变数组，则可以先qsort()排序，然后再用首尾指针。同理，对于三数之和的题目[leetcode-15], 就可以排序，然后固定一个数，然后就是上述的两数之和了，这样的话，可以在O(n^2) 的时间复杂度内解决。 前后指针 前指针先走k步，然后前后指针同步往后遍历。 [剑指offer-22] 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。如1->2->3->4->5->6，则倒数第3个节点 就是4所在的节点。 采用前后指针方法，如图所示： 前指针先走k步 前后指针一起走，直到前指针走到NULL 此时后指针指向的节点就是链表的倒数第k个节点 注意：如果链表长度小于k，该如何处理 /* before-after pointers to solve the problem */ struct list_node { int value; struct list_node *next; }; struct list_node *find_last_kth_node(struct list_node *head, int k) { int step = 0; struct list_node *before = head; struct list_node *after = head; /* before pointer move k step */ for (step = 0; step next; } /* list length next; after = after->next; } return after; } 从前指针的角度看，前指针从链表头遍历一遍到链表尾，故时间复杂度为O(n)。类似的题目如删除链表倒数第N个节点[leetcode-19]，需要注意的是，删除节点需要另外考虑头节点/中间节点/尾节点删除之后，节点之间指针的变化。 快慢指针 顾名思义，就是双指针中一个指针快一个指针慢，通常都是让快指针一次走2步，慢指针一次走1步。 [剑指offer-23] 链表中环的入口节点 如果链表中包含环，如何找出环的入口节点？如图所示，环的入口点为4的节点。 此问题分为两个小问题：如何判断是否有环？有环的情况下，如何得到环的入口点。 如何判断有环？这里就要使用快慢指针。我们想象，两个同学以不同的速度，同时从教室跑到操场， 然后开始绕操场跑圈。假如操场是直线的操场，那么跑得快的永远都在前面，直到尽头。操场是圆圈的操场，那么跑的慢的同学和跑的快的同学总会相遇，而且肯定是在操场上相遇。 快指针一次走2步，慢指针一次走1步，两个同时从头指针处开始走 如果快指针走到了NULL，那说明没有环 如果快指针与慢指针相遇了，说明存在环 Copyright © Jason 2019 all right reserved，powered by Gitbook本书发布时间： 2019-12-13 23:40:33 "}}